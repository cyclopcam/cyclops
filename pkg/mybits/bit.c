#include <string.h>
#include <stdint.h>
#include "bit.h"

// Set a range of bits
// This is more efficient than setting bits one by one, when 'len' spans multiple bytes.
void setbits(unsigned char* input, size_t i, size_t len) {
	size_t start          = i;
	size_t end            = i + len;
	size_t firstWholeByte = (start + 7) / 8;
	size_t lastWholeByte  = end / 8;
	if (firstWholeByte * 8 > start) {
		size_t startCap = firstWholeByte * 8 < end ? firstWholeByte * 8 : end;
		for (size_t i = start; i < startCap; i++) {
			setbit(input, i);
		}
	}

	if (lastWholeByte > firstWholeByte) {
		if (lastWholeByte - firstWholeByte > 4) {
			memset(input + firstWholeByte, 0xff, lastWholeByte - firstWholeByte);
		} else {
			for (size_t i = firstWholeByte; i < lastWholeByte; i++) {
				input[i] = 0xff;
			}
		}
	}

	if (lastWholeByte * 8 < end && firstWholeByte <= lastWholeByte) {
		size_t endCap = lastWholeByte * 8 > start ? lastWholeByte * 8 : start;
		for (size_t i = endCap; i < end; i++) {
			setbit(input, i);
		}
	}
}

// Compute the binary AND of 'a' and 'b', and return the number of bits set to 1.
size_t andbits_count(unsigned char* a, unsigned char* b, size_t bytesLength) {
	size_t total = 0;
	for (size_t i = 0; i < bytesLength; i++) {
		// Compute the AND of the corresponding bytes...
		unsigned char result = a[i] & b[i];
		// ... and add in the number of bits set to 1.
		total += __builtin_popcount((unsigned int) result);
	}
	return total;
}

// Compute the binary AND of 'a' and 'b', and return 1 if ANY of the bits are set, or 0 otherwise.
// (Generated by o3-mini-high)
int andbits_nonzero(unsigned char* a, unsigned char* b, size_t bytesLength) {
	// Process initial bytes until both a and b are aligned on an 8-byte boundary.
	// Instead of using % 8, we use the mask 7 (since 8 is a power of 2).
	while (bytesLength > 0 &&
	       (((uintptr_t) a & 7) != 0 || ((uintptr_t) b & 7) != 0)) {
		if ((*a & *b) != 0) {
			return 1;
		}
		a++;
		b++;
		bytesLength--;
	}

	// Process 8 bytes at a time.
	// Use >> 3 instead of / 8, and & 7 instead of % 8.
	size_t         numChunks = bytesLength >> 3; // same as bytesLength / 8
	const int64_t* a64       = (const int64_t*) a;
	const int64_t* b64       = (const int64_t*) b;
	for (size_t i = 0; i < numChunks; i++) {
		if ((a64[i] & b64[i]) != 0) {
			return 1;
		}
	}

	// Process any remaining tail bytes.
	a                = (unsigned char*) (a64 + numChunks);
	b                = (unsigned char*) (b64 + numChunks);
	size_t remaining = bytesLength & 7; // same as bytesLength % 8
	for (size_t i = 0; i < remaining; i++) {
		if ((a[i] & b[i]) != 0) {
			return 1;
		}
	}
	return 0;
}

void bitmap_fillrect(unsigned char* bitmap, int width, int x, int y, int w, int h) {
	if (width & 7) {
		return;
	}
	size_t         stride = width >> 3;
	unsigned char* p      = bitmap + y * stride;
	int            y2     = y + h;
	for (; y < y2; y++) {
		setbits(p, x, w);
		p += stride;
	}
}
